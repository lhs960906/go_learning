# 一、Go语言中的运算符
在Go中，有各种各样的运算符。按操作数的不同，运算符可以分为一元运算符和二元运算符（一元运运算符的操作数只有一个，而二元运算符的操作数则有两个）。某些时候一元运算符和二元运算符的样子可能相同，但他们却有着完全不一样的功能，例如运算符`^`在一元运算符中表示按位取反，而在二元运算符中却表示按位异或。
## 1.1、一元运算符
### 1.1.1、正数/负数（待补充）
```shell
+   # 正数；+x是0+x的简写 
-   # 负数；-x是0-x的简写
```
`+`运算符示例：
```go
var a int = 3
fmt.Println(+a)	// 打印3
```
`-`运算符示例：
```go
var a int = 3
fmt.Println(-a)	// 打印-3
```

### 1.1.2、指针运算符（待补充）
```shell
&   # 取变量地址
*   # 指针变量/操作地址对应内存
```
`&`运算符示例：
```go

```
`*`运算符示例：
```go

```

### 1.1.3、逻辑运算符
```shell
!   # 逻辑非
```
`!`运算符示例：
```go
fmt.Println(!true)  // 打印false
fmt.Println(!false) // 打印true
```
> Note：`!`右边为true时结果为false，反之则为true

### 1.1.4、位运算符
```shell
^   # 按位取反
```
`^`运算符示例：
```go
var a uint8 = 6
fmt.Println(^a) // ^00000110 = 11111001；打印249
```

## 1.2、二元运算符
### 1.2.1、算数运算符
```shell
+   # 加法
-   # 减法
*   # 乘法
/   # 除法
%   # 取模
++  # 自增
--  # 自减

+=  # 加法然后赋值
-=  # 减法然后赋值
*=  # 乘法然后赋值
/=  # 除法然后赋值
%=  # 取模然后赋值
```
`+`与`+=`运算符示例：
```go
var a int = 1
a += 1             // a=2
fmt.Println(a + 1) // 打印3
```
`-`与`-=`运算符示例：
```go
var a int = 1
a -= 1             // a=0
fmt.Println(a - 1) // 打印-1
```
`*`与`*=`运算符示例：
```go
var a int = 1
a *= 2             // a=2
fmt.Println(a * 2) // 打印4
```
`/`与`/=`运算符示例：
```go
var a int = 5
fmt.Println(a / 4)            // 打印1
fmt.Println(float64(a) / 4)   // 打印1.25
fmt.Println(float64(a) / 4.0) // 打印1.25
```
> Note：除法运算符/的行为则依赖于操作数是否全为整数，全为整数时除法会向着0方向截断余数。比如5.0/4.0的结果是1.25，但是5/4的结果是1。

`++`运算符示例：
```go
var a int = 5
a++             // a=6
fmt.Println(a)  // 打印6
```
`--`运算符示例：
```go
var a int = 5
a--             // a=4
fmt.Println(a)  // 打印4
```

### 1.2.2、逻辑运算符
```go
&&  # 逻辑与
||  # 逻辑或
!   # 逻辑非(注意这个是一元运算符)
```
`&&`运算符示例：
```go
fmt.Println(true && true)   // true
fmt.Println(true && false)  // false
fmt.Println(false && true)  // false
fmt.Println(false && false) // false
```
> Note：当 `&&` 两边全为true时，运算的结果才为true，否则为false

`||`运算符示例：
```go
fmt.Println(true || true)   // true
fmt.Println(true || false)  // true
fmt.Println(false || true)  // true
fmt.Println(false || false) // false
```
> Note：当 `||` 有一边为true时，运算的结果就为true，否则为false

### 1.2.3、比较运算符
两个相同的某些类型（比如两个相同的整型、浮点型、布尔、字符串）可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。
```go
>   # 大于
<   # 小于
>=  # 大于等于
<=  # 小于等于
==  # 等于
!=  # 不等于
```
`>`运算符示例：
```go
fmt.Println(3 > 2)  // true
fmt.Println(2 > 3)  // false
```
`<`运算符示例：
```go
fmt.Println(3 < 2)  // false
fmt.Println(2 < 3)  // true
```
`>=`运算符示例：
```go
fmt.Println(3 >= 2)  // true
fmt.Println(2 >= 3)  // false
```
`<=`运算符示例：
```go
fmt.Println(3 <= 2)  // false
fmt.Println(2 <= 3)  // true
```
`==`运算符示例：
```go
fmt.Println(3 == 3)  // true
fmt.Println(2 == 3)  // false
```
`!=`运算符示例：
```go
fmt.Println(3 != 3)  // false
fmt.Println(2 != 3)  // true
```

### 1.2.4、位运算符
Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：
```go
&   # 按位与AND；同为为1则为1
|   # 按位或OR；有1则为1
^   # 按位异或XOR；不同则为1
&^  # 按位置零(AND NOT)；对于`z=x&^y`，y中为1的比特位，x中与之的比特位被置为0，x的比特位置0后结果为z
<<  # 左移
>>  # 右移

&=  # 位运算AND然后赋值
|   # 位运算OR然后赋值
^=  # 位运算XOR然后赋值
&^= # 位清空(AND NOT)然后赋值
<<= # 左移然后赋值
>>= # 右移然后赋值
```
位运算符会对正数在内存中的二进制位进行操作，下表列出了位运算符的计算原则：
<table>
    <tr>
        <th>p</th>
        <th>q</th>
        <th>p&q</th>
        <th>p|q</th>
        <th>p^q</th>
        <th>p&^q</th>
    <tr>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
</table>

`&`与`&=`运算符示例：
```go
fmt.Println(uint8(1) & uint8(1))  // 00000001 & 00000001 = 00000001；打印1
fmt.Println(uint8(2) & uint8(1))  // 00000010 & 00000001 = 00000000；打印0
```
`|`与`|=`运算符示例：
```go
fmt.Println(1 | 1)  // 00000001 | 00000001 = 00000001；打印1
fmt.Println(2 | 1)  // 00000010 | 00000001 = 00000011；打印3
```
`^`与`^=`运算符示例：
```go
fmt.Println(1 ^ 1)  // 00000001 ^ 00000001 = 00000000；打印0
fmt.Println(2 ^ 1)  // 00000010 ^ 00000001 = 00000011；打印3
```
`&^`与`&^=`运算符示例：
```go
fmt.Println(1 &^ 1)  // 00000001 &^ 00000001 = 00000000；打印0
fmt.Println(2 &^ 1)  // 00000010 &^ 00000001 = 00000010；打印2
```
`<<`与`<<=`运算符示例：
```go

```
`>>`与`>>=`运算符示例：
```go

```

## 1.3、待整理
管道相关操作符：
```shell
<-  # 读管道/写管道
```

# 二、运算符优先级
## 2.1、一元运算符优先级（待补充）
待补充

## 2.2、二元运算符优先级
因为二元运算符是我们编程中常用的运算符，在构建复杂表达式的时候我们需要知道如何编译器会如何解析，这就要求我们了解运算符的优先级和结合性了。如下是一些我们常用的而运算符：
```shell
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```
二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级，例如：`mask & (1 << 28)`。

# 附录
## 附A：术语表
一元运算符：只需要一个操作数的运算符，例如
二元运算符：操作符符两边都有代操作异能素